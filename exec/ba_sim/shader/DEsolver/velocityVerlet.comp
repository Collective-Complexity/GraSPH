#version 450 core
#extension GL_ARB_compute_variable_group_size : require

#include "common.glsl"

layout(binding=PARTICLE_POSITION_BUFFER_BINDING,std430) buffer ParticlePositions
{
    vec4 positions[];
};

layout(binding=PARTICLE_VELOCITY_BUFFER_BINDING,std430) buffer ParticleVelocities
{
    vec4 velocities[];
};

layout(binding=PARTICLE_ACCELERATION_BUFFER_BINDING,std430) buffer ParticleAccelerations
{
    vec4 accelerations[];
};

layout(binding=VERLET_BUFFER_BINDING,std430) buffer VerletLastPositionBuffer
{
    vec4 lastAcceleration[];
};

layout(local_size_variable) in;

uniform float dt;
uniform float vel_dt;

// This shader performes a velocity verlet Integration step on a particle.
// for the first step set vel_dt to 0
// assumes A is only dependent on position
// velVerlet scheme:
// -----------------
// A(X_0)
// X_1 using X_0, V_0 and A_0
// A(X_1)
// V_1 using V_0, A_1 and A_0
// X_2 using X_1, V_1 and A_1
// A(X_2)
// V_2 using V_1, A_2 and A_1
// X_3 using X_2, V_2 and A_2
// ------------------
// Meaning that at the end of this function call the particle state will be
// lastAcceleration: A_i-1
// acceleration: A_i
// velocity: V_i
// position: X_i+1
void main()
{
    vec3 currPos = positions[gl_GlobalInvocationID.x].xyz;
    vec3 currVel = velocities[gl_GlobalInvocationID.x].xyz;
    vec3 oldAcc = lastAcceleration[gl_GlobalInvocationID.x].xyz;
    vec3 currAcc = accelerations[gl_GlobalInvocationID.x].xyz;

    vec3 newVel = currVel + 0.5*(currAcc+oldAcc)*vel_dt;
    vec3 newPos = currPos + newVel*dt + 0.5 * currAcc*dt*dt;

    positions[gl_GlobalInvocationID.x].xyz = newPos;
    velocities[gl_GlobalInvocationID.x].xyz = newVel;
    lastAcceleration[gl_GlobalInvocationID.x].xyz = currAcc;
    accelerations[gl_GlobalInvocationID.x] = vec4(0,0,0,0);
}