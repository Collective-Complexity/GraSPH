#version 450 core
// we have to use a fixed work group size here

#include "common.glsl"
#include "kernel.glsl"

layout(binding=PARTICLE_POSITION_BUFFER_BINDING,std430) buffer ParticlePositions
{
    vec4 positions[];
};

layout(binding=PARTICLE_VELOCITY_BUFFER_BINDING,std430) buffer ParticleVelocities
{
    vec4 velocities[];
};

layout(binding=PARTICLE_HYDRO_BUFFER_BINDING,std430) buffer ParticleHydro
{
    vec4 hydro[];
};

layout(binding=PARTICLE_SMLENGTH_BUFFER_BINDING,std430) buffer ParticleSmlength
{
    float smlength[];
};

layout(binding=PARTICLE_ACTIVE_BUFFER_BINDING,std430) buffer ParticleTimestep
{
    int isActive[];
};

layout(local_size_x=WGSIZE,local_size_y=1,local_size_z=1) in;

uniform float heps_factor = 0.1;

shared vec4 pos[gl_WorkGroupSize.x];
shared vec3 vel[gl_WorkGroupSize.x];
shared int wgHasActive=0;

// This shader updates a particles acceleration by interacting with all other particles,
// using shared memory to speed up memory access
void main()
{
    const int particleActive = isActive[gl_GlobalInvocationID.x];
    const uint startTile = TILES_PER_THREAD * uint(gl_GlobalInvocationID.x / NUM_PARTICLES); // there can be multiple threads per particle, so where do we start calculating?

    const uint idxi = gl_GlobalInvocationID.x % NUM_PARTICLES;
    const vec4 posi = positions[idxi];
    const float hi =  smlength[idxi];
    const vec3 veli = velocities[idxi].xyz;

    float density =0; // lets sum up the density here
    float densityPlus =0; // needed for drho/dh
    float densityMinus =0; // needed for drho/dh
    vec3 vorticity =vec3(0); // curl operator of the velocity
    float divergence =0; // divergence of the velocity

    // cache those values since we will always use the same h
    const float hi2 = hi*hi;
    const float hiPoly6Factor = poly6Factor(hi);

#ifndef DISABLE_DH_CORRECTION
    const float eps = hi*heps_factor;
    const float hipe = hi+eps;
    const float hime = hi-eps;
    const float hipe2 = hipe*hipe;
    const float hime2 = hime*hime;
    const float hipePoly6Factor = poly6Factor(hipe);
    const float himePoly6Factor = poly6Factor(hime);
#endif

#ifndef DISABLE_VISC_VORT_CORRECTION
    const float hiPolyGrad6Factor = poly6GradFactor(hi);
#endif

    // loop over tiles in a row for as many tiles one thread is configured to calculate
    // calculate the interactions of a particle with gl_WorkGroupSize.x particles in one tile
    // repeat until all interactions in all tiles are calculated
    for(uint tile = 0; tile < TILES_PER_THREAD; tile++)
    {
        // fill fields in shared memory
        uint idx = gl_WorkGroupSize.x * (startTile + tile) + gl_LocalInvocationID.x;
        pos[gl_LocalInvocationID.x] = positions[idx];
        vel[gl_LocalInvocationID.x] = velocities[idx].xyz;
        // sync
        memoryBarrierShared();
        barrier();
        // calculate the row up to here if this particle is active
        if(particleActive >0)
        for(uint j=0; j<gl_WorkGroupSize.x; j++)
        {
            const vec4 posj = pos[j];
            const vec3 velj = vel[j];
            const vec3 rij = posi.xyz - posj.xyz;
            const float r2 = dot(rij,rij);

            // calculate all densities
            density +=  posj.w * (Wpoly6(r2, hiPoly6Factor, hi2));

#ifndef DISABLE_DH_CORRECTION
            densityPlus +=  posj.w * (Wpoly6(r2, hipePoly6Factor, hipe2));
            densityMinus +=  posj.w * (Wpoly6(r2, himePoly6Factor, hime2));
#endif

#ifndef DISABLE_VISC_VORT_CORRECTION // remember to also disable this in the hydro accumulator
            // calculate vorticity and divergence of the velocity
            vec3 gradi = Wpoly6Grad(rij,r2,hiPolyGrad6Factor,hi2);
            vorticity +=  posj.w * cross(veli - velj, gradi);
            divergence += dot(velj - veli,gradi);
#endif
        }
        // sync
        memoryBarrierShared();
        barrier();
    }

    float vort = length(vorticity);
    // do not overwrite hydro data if particle is not active
    if(particleActive >0)
        hydro[gl_GlobalInvocationID.x] = vec4(vort, density, divergence, (densityPlus-densityMinus)/(2*eps));
}