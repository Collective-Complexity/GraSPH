#version 450 core
// we have to use a fixed work group size here

#include "common.glsl"
#include "kernel.glsl"

layout(binding=PARTICLE_POSITION_BUFFER_BINDING,std430) buffer ParticlePositions
{
    vec4 positions[];
};

layout(binding=PARTICLE_VELOCITY_BUFFER_BINDING,std430) buffer ParticleVelocities
{
    vec4 velocities[];
};

layout(binding=PARTICLE_ACCELERATION_BUFFER_BINDING,std430) buffer ParticleAccelerations
{
    vec4 accelerations[];
};

layout(binding=PARTICLE_HYDRO_BUFFER_BINDING,std430) buffer ParticleHydro
{
    vec4 hydro[];
};

layout(binding=PARTICLE_SMLENGTH_BUFFER_BINDING,std430) buffer ParticleSmlength
{
    float smlength[];
};

layout(local_size_x=WGSIZE,local_size_y=1,local_size_z=1) in;

uniform float gravity_constant;
uniform float eps_factor2;
uniform float k; // entropy of the fluid
uniform float alpha; // controle viscosity

shared vec4 pos[gl_WorkGroupSize.x];
shared vec4 hyd[gl_WorkGroupSize.x];
shared float h[gl_WorkGroupSize.x];
shared vec4 vel[gl_WorkGroupSize.x];

// This shader updates a particles acceleration by interacting with all other particles,
// using shared memory to speed up memory access
void main()
{
    const uint startTile = TILES_PER_THREAD * uint(gl_GlobalInvocationID.x / NUM_PARTICLES); // there can be multiple threads per particle, so where do we start calculating?

    // cache my particle attributes in local memory
    const uint idxi = gl_GlobalInvocationID.x % NUM_PARTICLES;
    const vec4 hydroi = hydro[idxi];
    const vec4 posi = positions[idxi];
    const float hi = smlength[idxi];
    const vec4 veli = velocities[idxi];

    vec3 accPressure = vec3(0); // lets sum up the acceleration here
    vec3 accGravity = vec3(0); // lets sum up the acceleration here
    float maxVsig = 0; // needed for the timestep criterion

    // calculate some values that are the same for all loop iterations
    const float pod2i = (hydroi.x / (hydroi.y*hydroi.y));
    const float hiSpikyGradFactor = spikyGradFactor(hi);

    // loop over tiles in a row for as many tiles one thread is configured to calculate
    // calculate the interactions of a particle with gl_WorkGroupSize.x particles in one tile
    // repeat until all interactions in all tiles are calculatedsss
    for(uint tile = 0; tile < TILES_PER_THREAD; tile++)
    {
        // fill fields in shared memory
        const uint tileStartIndex = gl_WorkGroupSize.x * (startTile + tile); // the index in the global buffer where this tile begins
        const uint idx= tileStartIndex + gl_LocalInvocationID.x;
        pos[gl_LocalInvocationID.x] = positions[idx];
        hyd[gl_LocalInvocationID.x] = hydro[idx];
        h[gl_LocalInvocationID.x] = smlength[idx];
        vel[gl_LocalInvocationID.x] = velocities[idx];
        // sync
        memoryBarrierShared();
        barrier();
        // calculate the row up to here use sink function if this is a sink particle
        for(uint j=0; j<gl_WorkGroupSize.x; j++) // go over everything in this tile
        {
            const vec4 posj = pos[j];
            const float hj = h[j];
            const vec4 hydroj = hyd[j];
            const vec4 velj = vel[j];

            const vec3 rij = posi.xyz - posj.xyz; // vector from i to j
            const float r2 = dot(rij,rij);
            const float dist = sqrt(r2); // distance from i to j

            // gravity
            accGravity.xyz +=  posj.w * -rij / sqrt(pow(r2+(hi*hj*eps_factor2),3)); // e2 =  ((hi*x + hj*x)*0.5)^2

            // pressure
            const float pod2j = hydroj.x / (hydroj.y*hydroj.y);

#ifdef FAST_PRESSURE
            accPressure -= posj.w * (pod2i+pod2j) * WspikyGrad(rij,dist,(hi+hj)*0.5);
#else
            const float pfi=1.0/(1+ hi/(3*hydroi.y) * hydroi.w);
            const float pfj=1.0/(1+ hj/(3*hydroj.y) * hydroj.w);

            const vec3 gradi = WspikyGrad(rij,dist,hi,hiSpikyGradFactor);
            const vec3 gradj = WspikyGrad(rij,dist,hj);

            accPressure -= posj.w * (pfi*pod2i* gradi + pfj*pod2j* gradj);
#endif

            // viscosity
#ifdef LAPLACE_VISC
            accPressure +=  alpha * posj.w  * (velj.xyz - veli.xyz)/hydroj.y * Wvisc(dist,(hi+hj)*0.5);
            maxVsig = max(maxVsig,length(velj));
#else
            const float vfij = (hydroi.z+hydroj.z)*0.5;

            float wij = dot(veli.xyz - velj.xyz,rij)/dist;
            wij = (wij <0) ? wij : 0;
            const float vsig = veli.w+velj.w - 3.0*wij;
            const float rhoij = (hydroj.y + hydroi.y)*0.5;
            const float II = vfij * -alpha*0.5 * vsig * wij / rhoij;

            maxVsig = max(maxVsig,vsig);
            accPressure -=  posj.w  * II * (gradi+gradj)*0.5f;
#endif
            }
        // sync
        memoryBarrierShared();
        barrier();
    }

    accelerations[gl_GlobalInvocationID.x] = vec4(accGravity*gravity_constant+accPressure,maxVsig);
}