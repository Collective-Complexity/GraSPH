#version 450 core
#extension GL_ARB_compute_variable_group_size : require
//#extension GL_NV_shader_atomic_float : require

#include "common.glsl"

layout(binding=PARTICLE_POSITION_BUFFER_BINDING,std430) buffer ParticlePositions
{
    vec4 positions[];
};

layout(binding=PARTICLE_VELOCITY_BUFFER_BINDING,std430) buffer ParticleVelocities
{
    vec4 velocities[];
};

layout(binding=PARTICLE_ACCELERATION_BUFFER_BINDING,std430) buffer ParticleAccelerations
{
    vec4 accelerations[];
};

layout(binding=PARTICLE_SMLENGTH_BUFFER_BINDING,std430) buffer ParticleSmlength
{
    float smlength[];
};

layout(binding=PARTICLE_TIMESTEP_BUFFER_BINDING,std430) buffer ParticleTimestep
{
    vec2 timestep[];
};

layout(binding=PARTICLE_ACTIVE_BUFFER_BINDING,std430) buffer IsParticleActive
{
    int isActive[];
};


layout(local_size_variable) in;

uniform float eps_factor;
uniform float gravity_accuracy;
uniform float courant_number;
uniform float smallest_timestep;
uniform float max_timestep;

// for the first step (not_first_step = 0) we get:
// calculate the total acceleration a_0( r_0, v_0)
// calculate velocity v_1/2( v_0, a_0)
// calculate position r_1( r_0, v_1/2)
// r_1 can then be used to calculate the next acceleration

// for every other step (not_first_step = 1)
// calculate total acceleration a_t( r_t, v_t-1/2)
// calculate velocity v_t( v_t-1/2, a_t)
// we have calculated r_t, a_t and v_t, dt may now be changed
// calculate velocity v_t+1/2( v_t, a_t) using the new timestep
// calculate position r_t+1( r_t, v_t+1/2) using new timestep
// r_t+1 and v_t+1/2 can now be used to calculate the next acceleration a_t+1

void main()
{
    vec3 vel = velocities[gl_GlobalInvocationID.x].xyz;
    vec2 tstp = timestep[gl_GlobalInvocationID.x];

    if( isActive[gl_GlobalInvocationID.x] >0)
    {
        // calculate the total acceleration a_t
        vec3 acc = vec3(0);
        float maxVsig=0;
        for(uint i=0; i < ACCELERATIONS_PER_PARTICLE; i++)
        {
            vec4 a = accelerations[NUM_PARTICLES * i + gl_GlobalInvocationID.x];
            acc = a.xyz;
            maxVsig = max(maxVsig,a.w);
        }

        // calculate velocity a_t
        vel = vel + acc.xyz * (tstp.x*0.5f);

#ifndef FIRST_STEP

        // calculate the maximal for this particle based on the criterion
        const float hi = smlength[gl_GlobalInvocationID.x];
        const float maxTimestep = min(max_timestep, min(courant_number * hi / maxVsig, sqrt(2*gravity_accuracy * hi*eps_factor / length(acc))));

        // find a small enough timestep in the power of two hirachy
        tstp.x = smallest_timestep;
        while(tstp.x+smallest_timestep <= maxTimestep)
        {
            tstp.x += smallest_timestep;
        }
        tstp.y = tstp.x;

        // calculate velocity a_t+1/2
        vel = vel + acc.xyz * (tstp.x*0.5f);
#endif
    }

    tstp.y -= smallest_timestep; // calculate time until particle bekomes active
    isActive[gl_GlobalInvocationID.x] = (tstp.y < smallest_timestep) ? 1 : 0;

    // calculate position r_t+1
    positions[gl_GlobalInvocationID.x].xyz += vel * smallest_timestep;
    velocities[gl_GlobalInvocationID.x].xyz = vel;
}