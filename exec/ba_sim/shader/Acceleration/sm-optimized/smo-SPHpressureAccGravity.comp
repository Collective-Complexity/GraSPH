#version 450 core
// we have to use a fixed work group size here

#include "common.glsl"
#include "mathConst.glsl"
#include "../softGravity.glsl"

layout(binding=PARTICLE_POSITION_BUFFER_BINDING,std430) buffer ParticlePositions
{
    vec4 positions[];
};

layout(binding=PARTICLE_VELOCITY_BUFFER_BINDING,std430) buffer ParticleVelocities
{
    vec4 velocities[];
};

layout(binding=PARTICLE_ACCELERATION_BUFFER_BINDING,std430) buffer ParticleAccelerations
{
    vec4 accelerations[];
};

layout(binding=PARTICLE_HYDRO_BUFFER_BINDING,std430) buffer ParticleHydro
{
    vec4 hydro[];
};

layout(local_size_x=WGSIZE,local_size_y=1,local_size_z=1) in;

uniform float smoothing_length;
uniform float visc;
uniform float gravity_constant;
uniform float smoothing_epsilon_squared;
uniform float sink_r;

shared vec4 pos[gl_WorkGroupSize.x];
shared vec4 hyd[gl_WorkGroupSize.x];
shared vec3 vel[gl_WorkGroupSize.x];

// some values that only depend on uniforms
float spikyScale = -45 / (PI * pow(smoothing_length,6));

// interact one particle with p others
void calculateTileRow( const in vec4 myPosition, const in vec4 myHydro, const in float pod2, const in vec3 myVel,  inout vec4 accG, inout vec3 accP)
{
    for(uint i=0; i<gl_WorkGroupSize.x; i++)
    {
        const vec4 iPos = pos[i];
        const vec4 iHydro = hyd[i];
        const vec3 iVel = vel[i];

        const vec3 r = myPosition.xyz - iPos.xyz;
        const float dist = length(r);

        accG.w = (iHydro.w < F_EPSILON && dist < sink_r) ? -1 : accG.w;
        accG.xyz += interaction(myPosition, pos[i], smoothing_epsilon_squared);
        accP -= (dist < smoothing_length && dist != 0) ? iHydro.w * ((iHydro.x / (iHydro.y*iHydro.y)) + pod2) * spikyScale * pow(smoothing_length - dist,2)* r/dist : vec3(0,0,0);
        accP += (dist < smoothing_length) ? visc * iHydro.w  * (iVel.xyz - myVel.xyz)/iHydro.y * -spikyScale * (smoothing_length - dist) : vec3(0,0,0);
    }
}

// interact one sink particle with p others
void calculateTileRowSink( const in vec4 myPosition, inout vec4 accG)
{
    for(uint i=0; i<gl_WorkGroupSize.x; i++)
    {
        const vec4 iPos = pos[i];
        const vec4 iHydro = hyd[i];
        const vec3 iVel = vel[i];

        const vec3 r = myPosition.xyz - iPos.xyz;
        const float dist = length(r);

        if( !(iHydro.w < F_EPSILON) && dist < sink_r) // check if the other particle needs to be consumed
        {
            accG.w += iPos.w;
            return;
        }
        accG.xyz += interaction(myPosition, pos[i], smoothing_epsilon_squared);
    }
}

// This shader updates a particles acceleration by interacting with all other particles,
// using shared memory to speed up memory access
void main()
{
    const uint startTile = TILES_PER_THREAD * uint(gl_GlobalInvocationID.x / NUM_PARTICLES); // there can be multiple threads per particle, so where do we start calculating?

    // cache my particle attributes in local memory
    const uint myIdx = gl_GlobalInvocationID.x % NUM_PARTICLES;
    const vec4 myPosition = positions[myIdx];
    const vec4 myHydro = hydro[myIdx];
    const vec4 myVel = velocities[myIdx];
    vec3 accPressure = vec3(0,0,0); // lets sum up the acceleration here
    vec4 accGravity = vec4(0,0,0,0); // lets sum up the acceleration here .w is the desired mass change caused by sink particles

    // calculate some values that are the same for all loop iterations
    float myPressureOverDensity2 = (myHydro.x / (myHydro.y*myHydro.y));

    // loop over tiles in a row for as many tiles one thread is configured to calculate
    // calculate the interactions of a particle with gl_WorkGroupSize.x particles in one tile
    // repeat until all interactions in all tiles are calculatedsss
    if(!(myHydro.w < F_EPSILON)) // is this a normal particle?
        for(uint tile = 0; tile < TILES_PER_THREAD; tile++)
        {
            // fill fields in shared memory
            const uint idx=gl_WorkGroupSize.x * (startTile + tile) + gl_LocalInvocationID.x;
            pos[gl_LocalInvocationID.x] = positions[idx];
            hyd[gl_LocalInvocationID.x] = hydro[idx];
            vel[gl_LocalInvocationID.x] = velocities[idx].xyz;
            // sync
            memoryBarrierShared();
            barrier();
            // calculate the row up to here use sink function if this is a sink particle
            calculateTileRow(myPosition,myHydro,myPressureOverDensity2,myVel.xyz,accGravity,accPressure);
            // sync
            memoryBarrierShared();
            barrier();
        }
    else // a sink particle
        for(uint tile = 0; tile < TILES_PER_THREAD; tile++)
        {
            // fill fields in shared memory
            const uint idx=gl_WorkGroupSize.x * (startTile + tile) + gl_LocalInvocationID.x;
            pos[gl_LocalInvocationID.x] = positions[idx];
            hyd[gl_LocalInvocationID.x] = hydro[idx];
            vel[gl_LocalInvocationID.x] = velocities[idx].xyz;
            // sync
            memoryBarrierShared();
            barrier();
            // calculate the row up to here use sink function if this is a sink particle
            calculateTileRowSink(myPosition,accGravity);
            // sync
            memoryBarrierShared();
            barrier();
        }

    // write back density and pressure
    accelerations[gl_GlobalInvocationID.x] = vec4(accGravity.xyz*gravity_constant+accPressure,accGravity.w);
}