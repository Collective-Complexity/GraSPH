#version 450 core
// we have to use a fixed work group size here
#extension GL_NV_shader_atomic_float : require

#include "common.glsl"
#include "mathConst.glsl"
#include "../softGravity.glsl"

layout(binding=PARTICLE_POSITION_BUFFER_BINDING,std430) buffer ParticlePositions
{
    vec4 positions[];
};

layout(binding=PARTICLE_VELOCITY_BUFFER_BINDING,std430) buffer ParticleVelocities
{
    vec4 velocities[];
};

layout(binding=PARTICLE_ACCELERATION_BUFFER_BINDING,std430) buffer ParticleAccelerations
{
    vec4 accelerations[];
};

layout(binding=PARTICLE_HYDRO_BUFFER_BINDING,std430) buffer ParticleHydro
{
    vec4 hydro[];
};

layout(local_size_x=WGSIZE,local_size_y=1,local_size_z=1) in;

uniform float visc;
uniform float gravity_constant;
uniform float smoothing_epsilon_squared;
uniform float smoothing_epsilon_squared_sph;
uniform float sink_r;
uniform float dt;

shared vec4 pos[gl_WorkGroupSize.x];
shared vec4 hyd[gl_WorkGroupSize.x];
shared vec3 vel[gl_WorkGroupSize.x];

// perform smoothing using the gradient of the spiky kernel
// rij is a vector posi - posj
// dist is ||rij||
// and h the smoothing length
vec3 Wspiky(vec3 rij, float dist  ,float h)
{
    return (dist <= h && dist != 0) ? (-45 / (PI * pow(h,6))) * pow(h - dist,2)* rij/dist : vec3(0,0,0);
}

// perform smoothing using the laplacian of the viscosity kernel
// rij is a vector posi - posj
// dist is ||rij||
// and h the smoothing length
float Wvisc(float dist, float h)
{
    return (dist <= h) ? (45 / (PI * pow(h,6))) * (h - dist) :0;
}

// This shader updates a particles acceleration by interacting with all other particles,
// using shared memory to speed up memory access
void main()
{
    const uint startTile = TILES_PER_THREAD * uint(gl_GlobalInvocationID.x / NUM_PARTICLES); // there can be multiple threads per particle, so where do we start calculating?

    // cache my particle attributes in local memory
    const uint idxi = gl_GlobalInvocationID.x % NUM_PARTICLES;
    const vec4 posi = positions[idxi];
    const vec4 hydroi = hydro[idxi];
    const vec4 veli = velocities[idxi];
    vec3 accPressure = vec3(0); // lets sum up the acceleration here
    vec4 accGravity = vec4(0); // lets sum up the acceleration here .w is the desired mass change caused by sink particles

    // calculate some values that are the same for all loop iterations
    const float pod2i = (hydroi.x / (hydroi.y*hydroi.y));

    // loop over tiles in a row for as many tiles one thread is configured to calculate
    // calculate the interactions of a particle with gl_WorkGroupSize.x particles in one tile
    // repeat until all interactions in all tiles are calculatedsss
        for(uint tile = 0; tile < TILES_PER_THREAD; tile++)
        {
            // fill fields in shared memory
            const uint tileStartIndex = gl_WorkGroupSize.x * (startTile + tile); // the index in the global buffer where this tile begins
            const uint idx= tileStartIndex + gl_LocalInvocationID.x;
            pos[gl_LocalInvocationID.x] = positions[idx];
            hyd[gl_LocalInvocationID.x] = hydro[idx];
            vel[gl_LocalInvocationID.x] = velocities[idx].xyz;
            // sync
            memoryBarrierShared();
            barrier();
            // calculate the row up to here use sink function if this is a sink particle
//            if(myHydro.w > 0) // is this a normal particle?
//            {
                for(uint j=0; j<gl_WorkGroupSize.x; j++) // go over everything in this tile
                {
                    const vec4 posj = pos[j];
                    const vec4 hydroj = hyd[j];
                    const vec3 velj = vel[j];

                    const vec3 r = posi.xyz - posj.xyz;
                    const float dist = length(r);

//                    if(iHydro.w > 0)
//                    {
//
                        accGravity.xyz += interaction(posi, posj, smoothing_epsilon_squared_sph);
                        const float pod2j = hydroj.x / (hydroj.y*hydroj.y);
                        accPressure -= hydroj.w * 0.5 * (pod2i * Wspiky(r,dist,hydroi.z) + pod2j * Wspiky(r,dist,hydroj.z));
                        accPressure +=  visc * hydroj.w  * (velj.xyz - veli.xyz)/hydroj.y * Wvisc(dist,hydroi.z);
//                    }

                }
//            }
//            else
//            {
//                for(uint i=0; i<gl_WorkGroupSize.x; i++) // go over everything in this tile
//                {
//                    const vec4 iPos = pos[i];
//
//                    const vec3 r = myPosition.xyz - iPos.xyz;
//                    const float dist = length(r);
//
//
//                        float iMassID;
//                        if( ((dist < sink_r && hyd[i].w > 0) /*|| (dist < sink_r/4 && iHydro.y < myHydro.y)*/ )
//                            &&((iMassID = atomicExchange(accelerations[tileStartIndex+i].w,-1)) >= 0))
//                        {
//                            atomicAdd(accelerations[myIdx].w,iPos.w);
//                            accGravity.w += iPos.w;
//                            accGravity.xyz += (((myPosition.w*myVel.xyz + iPos.w*vel[i].xyz) /  (iPos.w + myPosition.w)) - myVel.xyz) / 0.01;
//                        }
//                        else
//                            accGravity.xyz += interaction(myPosition, iPos, smoothing_epsilon_squared);
//                }
//            }
            // sync
            memoryBarrierShared();
            barrier();
        }

    // if needed write back velocity
//    if(myHydro.w > 0)
//        velocities[gl_GlobalInvocationID.x] = myVel;
    // write back acceleration
    accelerations[gl_GlobalInvocationID.x] = vec4(accGravity.xyz*gravity_constant+accPressure,accGravity.w);
}