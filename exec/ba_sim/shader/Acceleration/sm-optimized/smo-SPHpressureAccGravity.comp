#version 450 core
// we have to use a fixed work group size here

#include "common.glsl"
#include "mathConst.glsl"
#include "../softGravity.glsl"

layout(binding=PARTICLE_POSITION_BUFFER_BINDING,std430) buffer ParticlePositions
{
    vec4 positions[];
};

layout(binding=PARTICLE_VELOCITY_BUFFER_BINDING,std430) buffer ParticleVelocities
{
    vec4 velocities[];
};

layout(binding=PARTICLE_ACCELERATION_BUFFER_BINDING,std430) buffer ParticleAccelerations
{
    vec4 accelerations[];
};

layout(binding=PARTICLE_HYDRO_BUFFER_BINDING,std430) buffer ParticleHydro
{
    vec4 hydro[];
};

layout(local_size_x=WGSIZE,local_size_y=1,local_size_z=1) in;

uniform float smoothing_length;
uniform float visc;
uniform float gravity_constant;
uniform float smoothing_epsilon_squared;

shared vec4 pos[gl_WorkGroupSize.x];
shared vec4 hyd[gl_WorkGroupSize.x];
shared vec3 vel[gl_WorkGroupSize.x];

// some values that only depend on uniforms
float spikyScale = -45 / (PI * pow(smoothing_length,6));

// interact one particle with p others
void calculateTileRow( const in vec4 myPosition, const in vec4 myHydro, const in float pod2, const in vec3 myVel,  inout vec3 accG, inout vec3 accP)
{
    for(uint i=0; i<gl_WorkGroupSize.x; i++)
    {
        const vec3 r = myPosition.xyz - pos[i].xyz;
        const float dist = length(r);

        const vec4 iHydro = hyd[i];
        const vec3 iVel = vel[i];

        accG += interaction(myPosition, pos[i], smoothing_epsilon_squared);
        accP -= (dist < smoothing_length && dist != 0) ? hyd[i].w * ((iHydro.x / (iHydro.y*iHydro.y)) + pod2) * spikyScale * pow(smoothing_length - dist,2)* r/dist : vec3(0,0,0);
        accP += (dist < smoothing_length) ? visc * hyd[i].w  * (iVel.xyz - myVel.xyz)/iHydro.y * -spikyScale * (smoothing_length - dist) : vec3(0,0,0);

    }
}

// This shader updates a particles acceleration by interacting with all other particles,
// using shared memory to speed up memory access
void main()
{
    const uint startTile = TILES_PER_THREAD * uint(gl_GlobalInvocationID.x / NUM_PARTICLES); // there can be multiple threads per particle, so where do we start calculating?

    // cache my particle attributes in local memory
    const uint myIdx = gl_GlobalInvocationID.x % NUM_PARTICLES;
    const vec4 myPosition = positions[myIdx];
    const vec4 myHydro = hydro[myIdx];
    const vec4 myVel = velocities[myIdx];
    vec3 accPressure = vec3(0,0,0); // lets sum up the acceleration here
    vec3 accGravity = vec3(0,0,0); // lets sum up the acceleration here

    // calculate some values that are the same for all loop iterations
    float myPressureOverDensity2 = (myHydro.x / (myHydro.y*myHydro.y));

    // loop over tiles in a row for as many tiles one thread is configured to calculate
    // calculate the interactions of a particle with gl_WorkGroupSize.x particles in one tile
    // repeat until all interactions in all tiles are calculatedsss
    for(uint tile = 0; tile < TILES_PER_THREAD; tile++)
    {
        // fill fields in shared memory
        const uint idx=gl_WorkGroupSize.x * (startTile + tile) + gl_LocalInvocationID.x;
        pos[gl_LocalInvocationID.x] = positions[idx];
        hyd[gl_LocalInvocationID.x] = hydro[idx];
        vel[gl_LocalInvocationID.x] = velocities[idx].xyz;
        // sync
        memoryBarrierShared();
        barrier();
        // calculate the row up to here
        calculateTileRow(myPosition,myHydro,myPressureOverDensity2,myVel.xyz,accGravity,accPressure);
        // sync
        memoryBarrierShared();
        barrier();
    }

    // write back density and pressure
    accelerations[gl_GlobalInvocationID.x] = vec4(accGravity*gravity_constant+accPressure,0);
}