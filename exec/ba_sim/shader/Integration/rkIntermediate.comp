#version 450 core
#extension GL_ARB_compute_variable_group_size : require

#include "common.glsl"

layout(binding=RK_STATE_IN_BUFFER_BINDING,std430) buffer StateBuffer
{
    Particle state[];
};

layout(binding=RK_DERIV_BUFFER_BINDING,std430) buffer DerivativeBuffer
{
    Particle derivative[];
};

layout(binding=RK_OUT_BUFFER_BINDING,std430) buffer OutputBuffer
{
    Particle particlesOut[];
};


layout(local_size_variable) in;

uniform uint num_of_particles;
uniform float dt;

// This shader performs a semi-implicit euler step on one particle.
void main()
{
    if(gl_GlobalInvocationID.x >= num_of_particles)
        return;

    vec4 posIn = state[gl_GlobalInvocationID.x].position;
    vec4 dposIn = derivative[gl_GlobalInvocationID.x].velocity;

    vec4 velIn = state[gl_GlobalInvocationID.x].velocity;
    vec4 pvelIn = derivative[gl_GlobalInvocationID.x].acceleration;

    // advance the particles to t+dt based on the acceleration and velocity from the derivative buffer
    vec4 velOut = velIn + pvelIn * dt;
    vec4 posOut = posIn + dposIn * dt;

    particlesOut[gl_GlobalInvocationID.x].velocity = velOut;
    particlesOut[gl_GlobalInvocationID.x].position = posOut;
    particlesOut[gl_GlobalInvocationID.x].acceleration = vec4(0,0,0,0);
    particlesOut[gl_GlobalInvocationID.x].mass = state[gl_GlobalInvocationID.x].mass;
    // now calculate acceleration of the new paricles
}